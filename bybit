import time
import numpy as np
import pandas as pd
import torch
import torch.nn as nn
import torch.optim as optim
from pybit.unified_trading import HTTP
import os

# Konfigurera Bybit API från environment variables
API_KEY = os.getenv('BYBIT_API_KEY')
API_SECRET = os.getenv('BYBIT_API_SECRET')
TESTNET = True  # Ändra till False för live

session = HTTP(
    testnet=TESTNET,
    api_key=API_KEY,
    api_secret=API_SECRET
)

# ... (resten av koden är samma som i tidigare svar – indikatorer, modell, funktioner, huvudloop)
# Kopiera hela från tidigare meddelande om du behöver, men här är nyckeldelarna för att spara utrymme
# (Full kod finns i mitt föregående svar om Qovery – använd den, men byt till os.getenv för nycklar)

# Symbol och tidsram
SYMBOL = 'BTCUSDT'
INTERVAL = '5'  # 5 minuter
LIMIT = 200  # Candles för realtidsberäkningar
TRAIN_LIMIT = 1000  # Candles för träning (max per anrop är 1000)
MAX_QTY = 0.01  # Max qty per trade (justera efter konto)
RISK_PERCENT = 0.01  # Riskera max 1% av balansen per trade
SL_PERCENT = 0.01  # Stop-loss: 1% från inträde
TP_PERCENT = 0.02  # Take-profit: 2% från inträde

# Indikatorfunktioner
def calculate_rsi(prices, period=14):
    deltas = np.diff(prices)
    gains = np.where(deltas > 0, deltas, 0)
    losses = np.where(deltas < 0, -deltas, 0)
    
    avg_gain = np.mean(gains[:period])
    avg_loss = np.mean(losses[:period])
    
    if avg_loss == 0:
        rsi = np.full_like(prices, 100)
    else:
        rs = avg_gain / avg_loss
        rsi = np.full_like(prices, 100 - (100 / (1 + rs)))
    
    for i in range(period, len(prices)):
        current_gain = gains[i-1]
        current_loss = losses[i-1]
        avg_gain = (avg_gain * (period - 1) + current_gain) / period
        avg_loss = (avg_loss * (period - 1) + current_loss) / period
        if avg_loss == 0:
            rsi[i] = 100
        else:
            rs = avg_gain / avg_loss
            rsi[i] = 100 - (100 / (1 + rs))
    
    return rsi

def calculate_macd(prices, fast=12, slow=26, signal=9):
    def ema(data, period):
        ema = np.zeros_like(data)
        sma = np.mean(data[:period])
        ema[:period] = sma
        multiplier = 2 / (period + 1)
        for i in range(period, len(data)):
            ema[i] = (data[i] - ema[i-1]) * multiplier + ema[i-1]
        return ema
    
    ema_fast = ema(prices, fast)
    ema_slow = ema(prices, slow)
    macd_line = ema_fast - ema_slow
    signal_line = ema(macd_line, signal)
    histogram = macd_line - signal_line
    return macd_line, signal_line, histogram

# Enkel Torch-modell
class SimplePredictor(nn.Module):
    def __init__(self):
        super().__init__()
        self.fc1 = nn.Linear(3, 10)  # Input: RSI, MACD, Histogram
        self.fc2 = nn.Linear(10, 1)  # Output: -1 till 1 för sell/hold/buy
    
    def forward(self, x):
        x = torch.relu(self.fc1(x))
        x = torch.tanh(self.fc2(x))
        return x

model = SimplePredictor()

# Träna modellen med historiska data
def train_model():
    try:
        # Hämta historiska data (flera anrop om >1000 behövs, men här 1000)
        response = session.get_kline(
            category='linear',
            symbol=SYMBOL,
            interval=INTERVAL,
            limit=TRAIN_LIMIT
        )
        if response['retCode'] != 0:
            raise Exception(f"Fel vid hämtning av träningsdata: {response['retMsg']}")
        
        klines = response['result']['list']
        df = pd.DataFrame(klines, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume', 'turnover'])
        df['close'] = df['close'].astype(float)
        closes = df['close'].values[::-1]  # Äldst först
        
        # Beräkna indikatorer för hela dataset
        rsi = calculate_rsi(closes)
        macd, signal, hist = calculate_macd(closes)
        
        # Skapa inputs och labels (shiftad retur: (next_close - close)/close, klippt till -1/1)
        inputs = []
        labels = []
        for i in range(len(closes) - 1):
            inputs.append([rsi[i] / 100, macd[i], hist[i]])
            ret = (closes[i+1] - closes[i]) / closes[i]
            labels.append(max(min(ret, 1), -1))  # Klipp till -1 till 1
        
        inputs = torch.tensor(inputs, dtype=torch.float32)
        labels = torch.tensor(labels, dtype=torch.float32).unsqueeze(1)
        
        # Träning
        optimizer = optim.Adam(model.parameters(), lr=0.01)
        criterion = nn.MSELoss()
        for epoch in range(100):  # 100 epochs
            optimizer.zero_grad()
            outputs = model(inputs)
            loss = criterion(outputs, labels)
            loss.backward()
            optimizer.step()
            if epoch % 10 == 0:
                print(f"Epoch {epoch}, Loss: {loss.item()}")
        
        print("Modell tränad!")
    except Exception as e:
        print(f"Fel vid träning: {e}")

# Hämta kontobalans
def get_balance():
    try:
        response = session.get_wallet_balance(accountType='UNIFIED', coin='USDT')
        if response['retCode'] == 0:
            balances = response['result']['list'][0]['coin']
            for b in balances:
                if b['coin'] == 'USDT':
                    return float(b['walletBalance'])
        return 0
    except Exception as e:
        print(f"Fel vid hämtning av balans: {e}")
        return 0

# Hämta position
def get_position():
    try:
        response = session.get_positions(category='linear', symbol=SYMBOL)
        if response['retCode'] == 0:
            positions = response['result']['list']
            for pos in positions:
                if pos['symbol'] == SYMBOL and float(pos['size']) > 0:
                    return float(pos['size']), pos['side'], float(pos['avgPrice'])
        return 0, None, None
    except Exception as e:
        print(f"Fel vid hämtning av position: {e}")
        return 0, None, None

# Placera order med SL/TP och riskhantering
def place_order(side, qty, price=None, entry_price=None, is_open=True):
    try:
        order_type = 'Market' if price is None else 'Limit'
        params = {
            'category': 'linear',
            'symbol': SYMBOL,
            'side': side,
            'orderType': order_type,
            'qty': str(qty),
            'timeInForce': 'GTC'
        }
        if price:
            params['price'] = str(price)
        
        # Lägg till SL/TP om det är öppning av position
        if is_open and entry_price:
            if side == 'Buy':  # Öppna long
                sl_price = entry_price * (1 - SL_PERCENT)
                tp_price = entry_price * (1 + TP_PERCENT)
                params['stopLoss'] = str(round(sl_price, 2))
                params['takeProfit'] = str(round(tp_price, 2))
            elif side == 'Sell':  # Öppna short
                sl_price = entry_price * (1 + SL_PERCENT)
                tp_price = entry_price * (1 - TP_PERCENT)
                params['stopLoss'] = str(round(sl_price, 2))
                params['takeProfit'] = str(round(tp_price, 2))
            params['slTriggerBy'] = 'LastPrice'
            params['tpTriggerBy'] = 'LastPrice'
        
        response = session.place_order(**params)
        if response['retCode'] != 0:
            raise Exception(f"Fel vid orderplacering: {response['retMsg']}")
        return response
    except Exception as e:
        print(f"Fel vid order: {e}")
        return None

# Huvudloop
train_model()  # Träna en gång i början

while True:
    try:
        # Hämta kline data
        response = session.get_kline(
            category='linear',
            symbol=SYMBOL,
            interval=INTERVAL,
            limit=LIMIT
        )
        if response['retCode'] != 0:
            raise Exception(f"Fel vid hämtning av data: {response['retMsg']}")
        
        klines = response['result']['list']
        df = pd.DataFrame(klines, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume', 'turnover'])
        df['close'] = df['close'].astype(float)
        closes = df['close'].values[::-1]
        current_price = closes[-1]
        
        # Beräkna indikatorer
        rsi = calculate_rsi(closes)[-1]
        macd, signal, hist = calculate_macd(closes)
        macd_val = macd[-1]
        hist_val = hist[-1]
        
        # AI-prediktion
        inputs = torch.tensor([[rsi / 100, macd_val, hist_val]], dtype=torch.float32)
        prediction = model(inputs).item()
        
        # Hämta position och balans
        position_size, position_side, entry_price = get_position()
        balance = get_balance()
        
        # Beräkna qty baserat på risk (risk = balance * RISK_PERCENT / SL-avstånd)
        sl_distance = current_price * SL_PERCENT
        risk_qty = (balance * RISK_PERCENT) / sl_distance if sl_distance > 0 else MAX_QTY
        qty = min(risk_qty, MAX_QTY)
        
        # Logik för long och short
        if position_size == 0:  # Ingen position öppen
            if rsi < 30 and prediction > 0.5 and qty > 0:
                print("Köpsignal (long)! RSI:", rsi, "Pred:", prediction)
                place_order('Buy', qty, entry_price=current_price, is_open=True)
            elif rsi > 70 and prediction < -0.5 and qty > 0:
                print("Säljsignal (short)! RSI:", rsi, "Pred:", prediction)
                place_order('Sell', qty, entry_price=current_price, is_open=True)
        else:
            if position_side == 'Buy':  # Stäng long
                if rsi > 70 and prediction < -0.5:
                    print("Stäng long! RSI:", rsi, "Pred:", prediction)
                    place_order('Sell', position_size, is_open=False)
            elif position_side == 'Sell':  # Stäng short
                if rsi < 30 and prediction > 0.5:
                    print("Stäng short! RSI:", rsi, "Pred:", prediction)
                    place_order('Buy', position_size, is_open=False)
        
        print("Väntar... RSI:", rsi, "MACD Hist:", hist_val, "Pred:", prediction, "Balans:", balance)
        time.sleep(60 * 5)
    except Exception as e:
        print(f"Loopfel: {e}. Retry om 60s...")
        time.sleep(60)